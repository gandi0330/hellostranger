import numpy as np
import pandas as pd
from django.contrib.auth.decorators import login_required
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.models import User
from django.http import HttpResponse
from django.shortcuts import render, get_object_or_404

# Create your views here.
from django.urls import reverse_lazy, reverse
from django.utils.decorators import method_decorator
from django.views.generic import CreateView, DetailView, UpdateView, DeleteView
from django.views.generic.list import MultipleObjectMixin, ListView

from accountapp.decorators import account_ownership_required
from accountapp.forms import AccountUpdateForm
from playlistapp.models import Play
from profileapp.models import Profile

import pandas as pd
import numpy as np
from random import *
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.metrics import mean_squared_error
import warnings; warnings.filterwarnings('ignore')
has_ownership = [account_ownership_required, login_required]




class AccountCreateView(CreateView):
    model = User
    form_class = UserCreationForm
    success_url = reverse_lazy('accountapp:mainpage')
    template_name = 'accountapp/create.html'



class AccountDetailView(DetailView):
    model = User
    context_object_name =  'target_user'
    template_name = 'accountapp/detail.html'

    # paginate_by = 25

    # def get_context_data(self, **kwargs):
    #     object_list = Article.objects.filter(writer=self.get_object())
    #     return super(AccountDetailView, self).get_context_data(object_list=object_list, **kwargs)

@method_decorator(has_ownership, 'get')
@method_decorator(has_ownership, 'post')
class AccountUpdateView(UpdateView):
    model = User
    form_class = AccountUpdateForm
    context_object_name = 'target_user'
    success_url = reverse_lazy('accountapp:mainpage')
    template_name = 'accountapp/update.html'


@method_decorator(has_ownership, 'get')
@method_decorator(has_ownership, 'post')
class AccountDeleteView(DeleteView):
    model = User
    context_object_name = 'target_user'
    success_url = reverse_lazy('accountapp:login')
    template_name = 'accountapp/delete.html'

class ArticleListView(ListView):
    model = Play
    context_object_name = 'play_list'
    template_name = 'accountapp/mainpage.html'


def filtering(request, pk):
    area = request.GET.get('area')
    model = Play
    if area:
        model = model.objects.filter(area=area)
    context= {'object': model}
    return render(request, 'accountapp/filtering.html', context)




def recommend(request, pk):
    post = get_object_or_404(Profile,pk=pk)
    consumer_list = [[post.play1_title, post.play1_rate],[post.play2_title,post.play2_rate],[post.play3_title,post.play3_rate]]

    li = []
    recommend_list = ai(consumer_list)
    for recommend_play in recommend_list :
        li.append(Play.objects.get(title=recommend_play))

    context = {'object' : li}
    return render(request, 'accountapp/consumer.html', context)


# -*- coding: utf-8 -*-
"""해커톤 추천시스템(final).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z6SYP4tccJBIwm5Ij-YP05D363DEbcAp
"""

import pandas as pd
import numpy as np
import warnings;

warnings.filterwarnings('ignore')
from random import *
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity


# 장르 유사도에 따라 연극을 추천하는 함수
## df: 유사도 분석할 데이터프레임
## sorted_ind: 레코드별 장르 코사인 유사도 인덱스를 가지는 genre_sim_sorted_ind
## title: 고객이 선정한 추천 기준이 되는 연극 제목
## top_n: 추천할 연극 건수
## return : 추천 연극 정보 DataFrame
def find_sim_play(df, sorted_ind, title_name, top_n=5):
    title_play = df[df['title'] == title_name]
    title_index = title_play.index.values

    sim_indexs = sorted_ind[title_index, :top_n * 3]
    sim_indexs = sim_indexs.reshape(-1)

    sim_indexs = sim_indexs[sim_indexs != title_index]

    return df.iloc[sim_indexs].sort_values('weighted_vote', ascending=False)[:top_n]


# 데이터 전처리 함수
def data_preprocessing(plays, consumer_list):
    ## consumer_list에 입력된 공연(play)들의 title과 genre를 추출
    ## 추출된 genre를 genres_list에 저장
    ## 추출된 title과 genre들을 genres_dict에 저장
    genres_list = []
    genres_dict = {}
    idx_list = []
    for play in consumer_list:
        title = play[0]
        idx = plays.index[plays['title'] == title].tolist()[0]
        idx_list.append(idx)
        genres = plays.loc[idx, 'genres'].split()
        genres_dict[title] = genres
        for genre in genres:
            genres_list.append(genre)
    genres_list = list(set(genres_list))

    ## consumer가 이미 관람한 연극을 전체 연극데이터에서 제외 시키기
    for idx in idx_list:
        plays.drop(index=idx)

    ## consumer_df dataframe 생성
    ## index: consumer_list에 입력된 공연들의 title
    ## columns: genres_list에 입력된 공연들의 genres
    consumer_df = pd.DataFrame(data=genres_dict,
                               index=[x[0] for x in consumer_list],
                               columns=genres_list)

    ## consumer_df에 title과 genre에 대응하는 값 입력
    ## 이때, 가중치 조절을 위해 consumer_list에 입력된
    ## 공연별 평점에 3을 빼준다(1~5점으로 평가되는 평점의 중앙값)
    for play in genres_dict:
        for genre in genres_dict[play]:
            for data in consumer_list:
                if data[0] == play:
                    consumer_df.loc[play][genre] = 1 * (float(data[1]) - plays['vote_average'].mean())

    ## 각 장르별 점수를 합산하여 내림차순 정렬
    ## 상위 3개의 장르만 추출하여 consumer_play_genres 에 저장
    genres_rating = consumer_df.sum(axis=0).to_dict()
    genres_rating = sorted(genres_rating.items(), key=lambda x: x[1], reverse=True)
    consumer_play_genres = []
    for i in range(3):
        consumer_play_genres.append(genres_rating[i][0])

    ## consumer_play_df 생성
    ## playid : 0(기존 plays 데이터프레임과 중복되지 않는 임의의 값)
    ## title: consumer_play
    ## genres: consumer_play_genres에 저장된 장르들
    ## consumer_play_df를 plays 데이터프레임에 추가
    consumer_rating_avg = sum([float(x[1]) for x in consumer_list]) / len(consumer_list)
    consumer_play_list = [(0, 'consumer_play', ' '.join(consumer_play_genres), consumer_rating_avg, 1)]
    consumer_play_df = pd.DataFrame(consumer_play_list,
                                    columns=['playid', 'title', 'genres', 'vote_average', 'vote_count'])
    plays = plays.append(consumer_play_df, ignore_index=True)
    return plays


# 고객 데이터(consumer_list)를 입력 받아 맞춤 추천해주는 함수
def ai(consumer_list):
    # data_df_1.xlsx 파일은 views.py 와 같은 폴더에 있습니다
    plays_df = pd.read_excel('C:/Users/comn/PycharmProjects/recommendproject/accountapp/data_df_1.xlsx')

    # 1. 데이터 전처리 함수(data_preprocessing)
    plays = data_preprocessing(plays_df, consumer_list)

    # 2. 장르기반 추천 시스템
    ## CountVectorizer를 이용해 피처 벡터 행렬로 변환
    count_vect = CountVectorizer(min_df=0, ngram_range=(1, 1))
    genre_mat = count_vect.fit_transform(plays['genres'])

    ## 코사인 유사도(cosine_similarity) 계산계산
    ## 반환된 코사인 유사도 행렬을 정렬 및 인덱스 저장
    genre_sim = cosine_similarity(genre_mat, genre_mat)
    genre_sim_sorted_ind = genre_sim.argsort()[:, ::-1]

    ## 기존 평점을 가중 평점으로 변경
    C = plays['vote_average'].mean()
    m = plays['vote_count'].quantile(0.6)

    def weighted_vote_average(record):
        v = record['vote_count']
        R = record['vote_average']
        return ((v / (v + m)) * R) + ((m / (v + m)) * C)

    ## 가중평점 변경 함수(weighted_vote_average) 사용하여 가중평점 계산
    ## plays 데이터프레임에 가중평점 column 추가
    plays['weighted_vote'] = plays.apply(weighted_vote_average, axis=1)
    plays[['title', 'genres', 'vote_average', 'vote_count', 'weighted_vote']].sort_values('weighted_vote',
                                                                                          ascending=False)[:10]

    ## consumer_play: 이용자가 선호하는 장르를 바탕으로 가상의 연극명 지정
    ## 장르 유사도에 따라 연극을 추천하는 함수(find_sim_play) 사용
    ## return: 추천하는 연극의 title, genres, vote_avg, vote_cnt 출력
    sim_plays = find_sim_play(plays, genre_sim_sorted_ind, 'consumer_play')
    return list(sim_plays['title'].values)








